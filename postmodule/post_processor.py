#
# @author:charlotte.Song
# @file: post_processor.py
# @Date: 2019/3/7 15:22
# @description:
# -*- coding: utf-8 -*-
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
import numpy as np
import argparse
import torch
import cv2
import mmcv
import pycocotools.mask as maskUtils
import Polygon as plg
from functools import partial
""" To implement post-processing procedure 
    1. sort by confidence
    2. non-max suppression on IoU / softNMS on IoU
    3. min area sort
"""

def min_area_rect(cnt, scale=1.0):
    """
    :param cnt: the contours of mask generated from cv2.
    :return: 4 points of the min_area rect.
    """
    rect = cv2.minAreaRect(cnt)
    box = cv2.boxPoints(rect) * scale
    return box


def get_text_cc(mask, shape, ori_shape, min_area=300):
    """ use the mmcv to decode the mask,
        and then select the largest cc to be the instance mask.
        and generate cc for instance, and then filter the box
        return the list of rects.
    """
    mask = maskUtils.decode(mask).astype(np.bool)
    # pay attention
    scale = (ori_shape[1] * 1.0 / shape[1], ori_shape[0] * 1.0 / shape[0])
    instance_img = np.zeros(ori_shape, dtype=np.uint8)
    instance_img[mask] = 1
    (label_num, label, stats, _) = cv2.connectedComponentsWithStats(instance_img.astype(np.uint8), connectivity=4)
    lblareas = stats[:, cv2.CC_STAT_AREA]
    max_index = np.argmax(lblareas[1:]) + 1
    points = np.array(np.where(label == max_index)).transpose((1, 0))[:, ::-1]
    rect = cv2.minAreaRect(points)
    std_rect = cv2.boxPoints(rect) * scale
    std_rect = std_rect.astype(np.int32)
    return std_rect


# use the polygon to calculate the iou
def get_union(pa, pb):
    return pa.area() + pb.area() - get_intersection(pa, pb) + 1e-4


def get_intersection(pa, pb):
    pc = pa & pb
    return pc.area()


def get_polygon(box):
    return plg.Polygon(box)


def rect_nms(bbox_rects, bbox_scores, nms_thr=0.5):
    """
    implemented for NMS of rect bboxes.
    :param bbox_rects: rects which generated by get_text_cc.
    :param bbox_scores:the corresponding confidence scores.
    :param nms_thr: the filter threshold.
    :return:
    """
    assert len(bbox_rects) == len(bbox_scores)
    bbox_rects = np.asarray(bbox_rects)
    if len(bbox_rects) < 2:
        return bbox_rects
    bbox_scores = np.asarray(bbox_scores)

    idx = np.argsort(bbox_scores)[::-1]
    bbox_scores = bbox_scores[idx]
    bbox_rects = bbox_rects[idx]

    # use the bbox with max score to filter the small score bboxes.
    # if the IoU > 0.7 then filter the small ones.
    # first transform the rect to polygons.
    rect_polygons = []
    rect_areas = []
    for index in range(len(bbox_rects)):
        box = bbox_rects[index]
        polygon = plg.Polygon(box)
        rect_polygons.append(polygon)
        rect_areas.append(polygon.area)
    # to parallel deal with this task
    areas = np.asarray(rect_areas)
    idx = areas > 0
    bbox_rects = bbox_rects[idx]
    bbox_scores = bbox_scores[idx]

    # sort by bbox_scores
    _, order = torch.sort(bbox_scores, dim=0, descending=True)

    order_indices = order
    keep = []
    while len(order_indices) > 0:
        # filter for each bbox
        keep.append(order_indices[0])
        poly1 = plg.Polygon(bbox_rects[order_indices[0]])
        tmp_rects = [bbox_rects[i] for i in order_indices[1:]]
        iou = np.asarray(list(
            map(lambda x: get_intersection(poly1, get_polygon(x)) / get_union(poly1, get_polygon(x)), tmp_rects)))
        order_indices = order_indices[1:][iou < nms_thr]

    bbox_rects = bbox_rects[keep]
    bbox_scores = bbox_scores[keep]

    return bbox_rects, bbox_scores


def get_text_polygon(segm, mask_shape=None, scale_factor=None, min_area=0.0):
    """
    this method decode the mask and generate polygon for each cc.
    and the polygon size is fit to the original image.
    :param segm: RLE mask
    :return: a polygon
    """
    h, w, _ = mask_shape
    instance_mask = np.zeros((h, w), dtype=np.uint8)
    mask = maskUtils.decode(segm).astype(np.bool)
    if mask.shape[0] != h or mask.shape[1] != w:
        if abs(mask.shape[0] - h) < 2 and abs(mask.shape[1] - w) < 2:
            # mask = cv2.resize(mask, dsize=(w, h))
            instance_mask = cv2.resize(instance_mask, dsize=(mask.shape[1], mask.shape[0]))
        else:
            print(instance_mask.shape, mask.shape)
            raise Exception("error")
    instance_mask[mask] = 1
    (label_num, label, stats, _) = cv2.connectedComponentsWithStats(
        instance_mask.astype(np.uint8), connectivity=4)
    lblareas = stats[:, cv2.CC_STAT_AREA]
    if len(lblareas) <= 1:
        return None
    max_index = np.argmax(lblareas[1:]) + 1
    if lblareas[max_index] < min_area:
        return None
    # again
    instance_mask = 0 * instance_mask
    instance_mask[label == max_index] = 1
    _, cnt, _ = cv2.findContours(instance_mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    # cnt = cnt[0]
    # epsilon = 0.01 * cv2.arcLength(cnt, True)
    # box = cv2.approxPolyDP(cnt, epsilon, True)
    box = cnt[0]
    # scale_factor = [ori_w / mask_w, ori_h / mask_h]
    box = ((box.reshape(-1, 2)) * scale_factor).astype(np.int32)
    if box.shape[0] < 3:
        return None
    box = plg.Polygon(box)
    return box


def polygon_nms(polygon_bboxes, polygon_scores, nms_thr=0, conf_thr=0):
    """ nms method for polygon bboxes """
    assert len(polygon_bboxes) == len(polygon_scores)
    if len(polygon_bboxes) < 2:
        return polygon_bboxes, polygon_scores
    polygon_scores = np.asarray(polygon_scores)

    # first rearrange the order of bboxes by their scores
    ordered_idx = np.array(np.argsort(polygon_scores)[::-1])
    polygon_scores = polygon_scores[ordered_idx]
    polygon_bboxes = [polygon_bboxes[i] for i in ordered_idx]
    ordered_idx = np.arange(0, len(polygon_bboxes), dtype=np.int64)
    keep = []
    while len(ordered_idx) > 0:
        keep.append(ordered_idx[0])
        poly_0 = polygon_bboxes[ordered_idx[0]]
        tmp_polys = [polygon_bboxes[i] for i in ordered_idx[1:]]
        ious = np.asarray(list(map(lambda x: get_intersection(poly_0, x) / get_union(poly_0, x), tmp_polys)))
        # keep the bboxes that iou < thr
        ordered_idx = ordered_idx[1:][ious < nms_thr]
    nms_polygon_bboxes = [polygon_bboxes[i] for i in keep]
    nms_polygon_scores = polygon_scores[keep]

    # filter by scores
    indx = np.where(nms_polygon_scores > conf_thr)[0]
    nms_polygon_bboxes = [nms_polygon_bboxes[i] for i in indx]
    nms_polygon_scores = nms_polygon_scores[indx]
    return nms_polygon_bboxes, nms_polygon_scores


def polygon_softnms(polygon_boxes, polygon_scores, conf_thr=0, sigma=0,
                    soft_sort=None, **kwargs):
    """ implement soft-nsm """
    assert len(polygon_boxes) == len(polygon_scores)
    assert sigma > 0
    if len(polygon_boxes) < 2:
        return polygon_boxes, polygon_scores
    polygon_scores = np.asarray(polygon_scores)

    # first rearrange the order of bboxes by their scores
    order_idx = np.array(np.argsort(polygon_scores)[::-1])
    polygon_scores = polygon_scores[order_idx]
    polygon_boxes = [polygon_boxes[i] for i in order_idx]
    order_idx = np.arange(0, len(polygon_boxes), dtype=np.int64)
    if eval(soft_sort):
        keep = []
        while(len(order_idx)) > 0:
            keep.append(order_idx[0])   # keep the high score bboxes.
            poly_0 = polygon_boxes[order_idx[0]]
            tmp_polys = [polygon_boxes[i] for i in order_idx[1:]]
            ious = np.asarray(list(map(lambda x: get_intersection(poly_0, x) / get_union(poly_0, x), tmp_polys)))
            score_decay = np.exp(- ious ** 2 / sigma)
            polygon_scores[order_idx[1:]] = polygon_scores[order_idx[1:]] * score_decay
            # rearrange the order
            px = np.array(np.argsort(polygon_scores[order_idx[1:]])[::-1])
            order_idx = order_idx[1:][px]
        nms_polygon_bboxes = [polygon_boxes[i] for i in keep]
        nms_polygon_scores = polygon_scores[keep]
    else:
        while(len(order_idx)) > 0:
            poly_0 = polygon_boxes[order_idx[0]]
            tmp_polys = [polygon_boxes[i] for i in order_idx[1:]]
            ious = np.asarray(list(map(lambda x: get_intersection(poly_0, x) / get_union(poly_0, x), tmp_polys)))
            score_decay = np.exp(- ious ** 2 / sigma)
            polygon_scores[order_idx[1:]] = polygon_scores[order_idx[1:]] * score_decay
            order_idx = order_idx[1:]
        nms_polygon_bboxes = polygon_boxes
        nms_polygon_scores = polygon_scores
    # rearrange the order by scores
    px = np.array(np.argsort(nms_polygon_scores)[::-1])
    n_nms_polygon_scores, n_nms_polygon_bboxes = [], []
    for i in px:
        if nms_polygon_scores[i] > conf_thr:
            n_nms_polygon_scores.append(nms_polygon_scores[i])
            n_nms_polygon_bboxes.append(nms_polygon_bboxes[i])
        else:
            break
    n_nms_polygon_scores = np.asarray(n_nms_polygon_scores)
    return n_nms_polygon_bboxes, n_nms_polygon_scores


class PostProcessor(object):
    # def __init__(self, conf_thr_sec=0.7, nms_thr=0.1, conf_thr_fir=0.0,
    #              min_area=0.0, nms_mode='nms', **kwargs):
    def __init__(self, conf_thr_fir=0.0, min_area=0.0, nms_mode='nms',
                 nms_setting=None, **kwargs):
        """
        :param conf_thr_fir:
        :param min_area:
        :param nms_mode:
        :param nms_setting:dict("nms_thr": , "conf_thr_sec": , "sigma": )
        :param kwargs:
        """
        # self.conf_thr = conf_thr
        # self.nms_thr= nms_thr
        # do not filter the small regions.
        # self.min_area_thr = min_area_thr
        assert nms_setting is not None
        self.conf_thr_fir = conf_thr_fir
        self.conf_thr_sec = nms_setting['conf_thr']
        self.nms_thr = nms_setting['nms_thr']
        # to filter out the small area.
        self.min_area_thr = min_area
        self.nms_mode = nms_mode
        self.nms_setting = nms_setting

    def process(self, segms, segms_scores, mask_shape, scale_factor=1.0):
        # get the mask
        # first use the maskUtils and ori_img to decode the masks.
        # segms is the list of RLE
        # the segms_scores are first ordered by scores.
        assert len(segms) == len(segms_scores)
        h, w, _ = mask_shape
        # filter out the low-confidence bboxes
        inds = np.where(segms_scores > self.conf_thr_fir)[0]
        polygon_bboxes, keep = [], []

        for i in inds:
            # genreate polygon from mask
            # filter out small boxes.
            polygon = get_text_polygon(segms[i], mask_shape, scale_factor,
                                       min_area=self.min_area_thr)
            if polygon is not None:
                keep.append(i)
                polygon_bboxes.append(polygon)
        polygon_scores = np.asarray(segms_scores[keep])
        if self.nms_mode == 'nms':
            return polygon_nms(polygon_bboxes, polygon_scores,
                               nms_thr=self.nms_thr, conf_thr=self.conf_thr_sec)
        elif self.nms_mode == 'soft_nms':
            return polygon_softnms(polygon_bboxes, polygon_scores, **self.nms_setting)





